import path from "path";
import electron, { app, Menu, shell, BrowserWindow } from "electron";
import installDevToolExtension, {
  REDUX_DEVTOOLS,
  REACT_DEVELOPER_TOOLS
} from "electron-devtools-installer";
import { imageToIconEventHandler } from "./app/ipc/image-to-icon/event-handlers";
import { inDebugMode } from "./utils";
import packageJson from "../../package.json";

/**
 * This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
 * plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
 * whether you're running in development or production).
 */
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export class DesktopToolsWindow {
  private resourcesPath = app.isPackaged
    ? path.join(process.resourcesPath, "assets")
    : path.join(__dirname, "../../assets");

  private window: BrowserWindow;

  constructor() {
    // Create the browser window.
    this.window = new BrowserWindow({
      title: packageJson.displayName,
      icon: path.join(this.resourcesPath, "icon.png"),
      height: 720,
      width: 1024,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        nodeIntegration: true
      },
      resizable: true
    });
  }

  private addWindowMenu() {
    const menu = Menu.buildFromTemplate([
      {
        label: "File",
        submenu: [
          {
            label: "Exit",
            role: "quit"
          },
          { label: "Reload", role: "reload" },
          // open devtools
          {
            label: "DevTools",
            role: "toggleDevTools"
          }
        ]
      }
    ]);

    if (inDebugMode()) {
      this.window.webContents.on("context-menu", (_, props) => {
        const { x, y } = props;

        Menu.buildFromTemplate([
          {
            label: "Inspect element",
            click: () => {
              this.window.webContents.inspectElement(x, y);
            }
          }
        ]).popup({ window: this.window });
      });
      return;
    }

    Menu.setApplicationMenu(menu);
  }

  public async addWindowEventListeners() {
    this.window.on("ready-to-show", () => {
      if (!this.window) {
        throw new Error('"mainWindow" is not defined');
      }

      this.window.webContents.openDevTools();
      this.window.show();
    });

    this.window.on("close", () => {
      app.quit();
    });

    this.window.webContents.setWindowOpenHandler((edata) => {
      shell.openExternal(edata.url);
      return { action: "deny" };
    });

    this.attachToMainProcess(imageToIconEventHandler);

    return this;
  }

  private attachToMainProcess(attachHandler: (ipcMain: Electron.IpcMain) => void) {
    attachHandler(electron.ipcMain);
  }

  public async installDevToolExtensions() {
    const supportedExtensions = {
      [REACT_DEVELOPER_TOOLS.id]: {
        name: "react-devtools",
        reference: REACT_DEVELOPER_TOOLS
      },
      [REDUX_DEVTOOLS.id]: {
        name: "redux-devtools",
        reference: REDUX_DEVTOOLS
      }
    };

    for (const supportedExtension of Object.entries(supportedExtensions)) {
      const extensionId = supportedExtension[0];
      const extensionDetails = supportedExtension[1];

      try {
        await installDevToolExtension(extensionDetails.reference, {
          forceDownload: true,
          loadExtensionOptions: {
            allowFileAccess: true
          }
        });

        console.log(`Installed extension: ${extensionDetails.name} (${extensionId})`);
      } catch (error) {
        throw new Error(
          `Failed to install devtools extension: ${extensionDetails.name}\nMessage: ${error.message}\nDetails: ${error.stack}`
        );
      }
    }

    return this;
  }

  public async init() {
    await this.addWindowEventListeners();
    await this.installDevToolExtensions();
    await this.window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    this.addWindowMenu();
    this.window.webContents.openDevTools();
  }
}
